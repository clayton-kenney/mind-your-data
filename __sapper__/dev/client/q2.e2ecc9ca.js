import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, K as validate_each_argument, o as createEventDispatcher, v as validate_slots, O as onMount, N as afterUpdate, e as element, a as space, t as text, f as claim_element, g as children, c as claim_space, h as claim_text, b as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, R as listen_dev, q as query_selector_all, J as set_data_dev, n as noop, M as destroy_each, Q as null_to_empty } from './client.c361c228.js';
import { C as Completion } from './Completion.4cef1de0.js';

/* src/routes/quiz/q2.svelte generated by Svelte v3.23.2 */
const file = "src/routes/quiz/q2.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	child_ctx[16] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

// (81:2) {:else}
function create_else_block(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("some text");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "some text");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file, 81, 2, 2348);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(81:2) {:else}",
		ctx
	});

	return block;
}

// (74:2) {#if !isActive}
function create_if_block(ctx) {
	let h3;
	let t0;
	let t1;
	let t2;
	let ul;
	let each_value_1 = /*q1Steps*/ ctx[0];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			h3 = element("h3");
			t0 = text("Search Engine ");
			t1 = text(/*fraction*/ ctx[5]);
			t2 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Search Engine ");
			t1 = claim_text(h3_nodes, /*fraction*/ ctx[5]);
			h3_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file, 74, 2, 2203);
			attr_dev(ul, "class", "svelte-1tvhnpi");
			add_location(ul, file, 75, 2, 2239);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t0);
			append_dev(h3, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fraction*/ 32) set_data_dev(t1, /*fraction*/ ctx[5]);

			if (dirty & /*q1Steps*/ 1) {
				each_value_1 = /*q1Steps*/ ctx[0];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(74:2) {#if !isActive}",
		ctx
	});

	return block;
}

// (77:3) {#each q1Steps as step}
function create_each_block_1(ctx) {
	let li;
	let t_value = /*step*/ ctx[17].name + "";
	let t;
	let li_class_value;

	const block = {
		c: function create() {
			li = element("li");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			t = claim_text(li_nodes, t_value);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*step*/ ctx[17].classn) + " svelte-1tvhnpi"));
			add_location(li, file, 77, 4, 2275);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*q1Steps*/ 1 && t_value !== (t_value = /*step*/ ctx[17].name + "")) set_data_dev(t, t_value);

			if (dirty & /*q1Steps*/ 1 && li_class_value !== (li_class_value = "" + (null_to_empty(/*step*/ ctx[17].classn) + " svelte-1tvhnpi"))) {
				attr_dev(li, "class", li_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(77:3) {#each q1Steps as step}",
		ctx
	});

	return block;
}

// (89:3) {#each browserChoice as browsers, index}
function create_each_block(ctx) {
	let label;
	let input;
	let input_value_value;
	let t0;
	let t1_value = /*browsers*/ ctx[14].name + "";
	let t1;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			input = claim_element(label_nodes, "INPUT", { type: true, value: true });
			t0 = claim_space(label_nodes);
			t1 = claim_text(label_nodes, t1_value);
			t2 = claim_space(label_nodes);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "radio");
			input.__value = input_value_value = /*index*/ ctx[16];
			input.value = input.__value;
			/*$$binding_groups*/ ctx[9][0].push(input);
			add_location(input, file, 90, 5, 2521);
			attr_dev(label, "class", "svelte-1tvhnpi");
			add_location(label, file, 89, 4, 2508);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			input.checked = input.__value === /*choice*/ ctx[2];
			append_dev(label, t0);
			append_dev(label, t1);
			append_dev(label, t2);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*choice*/ 4) {
				input.checked = input.__value === /*choice*/ ctx[2];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*$$binding_groups*/ ctx[9][0].splice(/*$$binding_groups*/ ctx[9][0].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(89:3) {#each browserChoice as browsers, index}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section0;
	let t1;
	let div;
	let h1;
	let t2;
	let t3;
	let p;
	let t4;
	let t5;
	let form;
	let t6;
	let section1;
	let button;
	let t7;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (!/*isActive*/ ctx[1]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);
	let each_value = /*browserChoice*/ ctx[6];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			t0 = space();
			section0 = element("section");
			if_block.c();
			t1 = space();
			div = element("div");
			h1 = element("h1");
			t2 = text(/*headline*/ ctx[3]);
			t3 = space();
			p = element("p");
			t4 = text(/*body*/ ctx[4]);
			t5 = space();
			form = element("form");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t6 = space();
			section1 = element("section");
			button = element("button");
			t7 = text("Submit");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1ux4qy8\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section0 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section0_nodes = children(section0);
			if_block.l(section0_nodes);
			section0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h1 = claim_element(div_nodes, "H1", {});
			var h1_nodes = children(h1);
			t2 = claim_text(h1_nodes, /*headline*/ ctx[3]);
			h1_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			p = claim_element(div_nodes, "P", {});
			var p_nodes = children(p);
			t4 = claim_text(p_nodes, /*body*/ ctx[4]);
			p_nodes.forEach(detach_dev);
			t5 = claim_space(div_nodes);
			form = claim_element(div_nodes, "FORM", { class: true });
			var form_nodes = children(form);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(form_nodes);
			}

			form_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);
			section1 = claim_element(div_nodes, "SECTION", { id: true });
			var section1_nodes = children(section1);
			button = claim_element(section1_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t7 = claim_text(button_nodes, "Submit");
			button_nodes.forEach(detach_dev);
			section1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Search Engine";
			attr_dev(section0, "id", "progress");
			attr_dev(section0, "class", "svelte-1tvhnpi");
			add_location(section0, file, 72, 1, 2159);
			add_location(h1, file, 85, 2, 2414);
			add_location(p, file, 86, 2, 2436);
			attr_dev(form, "class", "svelte-1tvhnpi");
			add_location(form, file, 87, 2, 2453);
			attr_dev(button, "class", "btn-dark svelte-1tvhnpi");
			add_location(button, file, 96, 3, 2661);
			attr_dev(section1, "id", "next-skip");
			add_location(section1, file, 95, 2, 2632);
			attr_dev(div, "class", "quiz-holder svelte-1tvhnpi");
			add_location(div, file, 84, 1, 2386);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section0, anchor);
			if_block.m(section0, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(h1, t2);
			append_dev(div, t3);
			append_dev(div, p);
			append_dev(p, t4);
			append_dev(div, t5);
			append_dev(div, form);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(form, null);
			}

			append_dev(div, t6);
			append_dev(div, section1);
			append_dev(section1, button);
			append_dev(button, t7);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*showResults*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(section0, null);
				}
			}

			if (dirty & /*headline*/ 8) set_data_dev(t2, /*headline*/ ctx[3]);
			if (dirty & /*body*/ 16) set_data_dev(t4, /*body*/ ctx[4]);

			if (dirty & /*browserChoice, choice*/ 68) {
				each_value = /*browserChoice*/ ctx[6];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(form, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section0);
			if_block.d();
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

	function complete() {
		dispatch("message", { q1: "true" });
	}

	let q1Steps = [
		{
			stepNum: "1",
			h2: "What Search Engine do you use?",
			name: "Introduction",
			classn: "complete",
			d: "1 / 3",
			browsers: ["Google Chrome", "DuckDuckGo", "Bing", "Something", "Something"],
			copy: "Did you know everything time you look up something using search engine, you are giving your information to thousands of 3rd party advertisers? Vast amount of your data has been taken from you without a single consent only to manipulate your purchase habit and long-term behavior. In this exercise, we will walk through with you how to avoid...."
		}
	];

	let browserChoice = [
		{
			name: "Google Chrome",
			value: 1,
			safety: "37%",
			body: "Google Chrome collectes X number of individual data per year. Google probably knows more about you than even Facebook does, thanks to the things you tell it when you type queries into its search engine. Though that’s just the tip of how it tracks you. It also has its tracking infrastructure embedded on three-quarters of the top million websites. So chances are it’s following what you’re browsing online."
		},
		{
			name: "DuckDuckGo",
			value: 2,
			safety: "73%",
			body: "Something something"
		},
		{
			name: "DuckDuckGo",
			value: 3,
			safety: 1,
			body: 1
		},
		{
			name: "something1",
			value: 4,
			safety: 1,
			body: 1
		},
		{
			name: "something2",
			value: 5,
			safety: 1,
			body: 1
		}
	];

	let isActive;

	function stepUp() {
		$$invalidate(10, q++, q);
		$$invalidate(0, q1Steps[q].classn = "complete", q1Steps);

		if (q == 2) {
			$$invalidate(1, isActive = true);
		}

		if (q > 2) {
			complete();

			stream.getTracks().forEach(function (track) {
				track.stop();
			});
		}
	}

	let choice = ["Google Chrome"];

	function showResults(event) {
		$$invalidate(1, isActive = true);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Q2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Q2", $$slots, []);
	const $$binding_groups = [[]];

	function input_change_handler() {
		choice = this.__value;
		$$invalidate(2, choice);
	}

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		createEventDispatcher,
		Completion,
		dispatch,
		complete,
		q1Steps,
		browserChoice,
		isActive,
		stepUp,
		choice,
		showResults,
		q,
		headline,
		body,
		fraction
	});

	$$self.$inject_state = $$props => {
		if ("q1Steps" in $$props) $$invalidate(0, q1Steps = $$props.q1Steps);
		if ("browserChoice" in $$props) $$invalidate(6, browserChoice = $$props.browserChoice);
		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
		if ("choice" in $$props) $$invalidate(2, choice = $$props.choice);
		if ("q" in $$props) $$invalidate(10, q = $$props.q);
		if ("headline" in $$props) $$invalidate(3, headline = $$props.headline);
		if ("body" in $$props) $$invalidate(4, body = $$props.body);
		if ("fraction" in $$props) $$invalidate(5, fraction = $$props.fraction);
	};

	let q;
	let headline;
	let body;
	let fraction;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*q1Steps, q*/ 1025) {
			 $$invalidate(3, headline = q1Steps[q].h2);
		}

		if ($$self.$$.dirty & /*q1Steps, q*/ 1025) {
			 $$invalidate(4, body = q1Steps[q].copy);
		}

		if ($$self.$$.dirty & /*q1Steps, q*/ 1025) {
			 $$invalidate(5, fraction = q1Steps[q].d);
		}
	};

	 $$invalidate(10, q = 0);

	return [
		q1Steps,
		isActive,
		choice,
		headline,
		body,
		fraction,
		browserChoice,
		showResults,
		input_change_handler,
		$$binding_groups
	];
}

class Q2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Q2",
			options,
			id: create_fragment.name
		});
	}
}

export default Q2;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicTIuZTJlY2M5Y2EuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcXVpei9xMi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cblx0aW1wb3J0IHsgb25Nb3VudCwgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgQ29tcGxldGlvbiBmcm9tICcuLi8uLi9jb21wb25lbnRzL0NvbXBsZXRpb24uc3ZlbHRlJ1xuXHRcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0XG5cdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdGRpc3BhdGNoKCdtZXNzYWdlJywge1xuXHRcdFx0cTE6ICd0cnVlJ1xuXHRcdH0pO1xuXHR9XG5cdFx0bGV0IHExU3RlcHMgPSBbXG5cdFx0eyBzdGVwTnVtOiAnMScsIFxuXHRcdGgyOiAnV2hhdCBTZWFyY2ggRW5naW5lIGRvIHlvdSB1c2U/JywgXG5cdFx0bmFtZTogJ0ludHJvZHVjdGlvbicsIFxuXHRcdGNsYXNzbjogJ2NvbXBsZXRlJyxcblx0XHRkOiAnMSAvIDMnLFxuXHRcdGJyb3dzZXJzOiBbJ0dvb2dsZSBDaHJvbWUnLCAnRHVja0R1Y2tHbycsICdCaW5nJywgJ1NvbWV0aGluZycsICdTb21ldGhpbmcnXSxcblx0XHRjb3B5OiAnRGlkIHlvdSBrbm93IGV2ZXJ5dGhpbmcgdGltZSB5b3UgbG9vayB1cCBzb21ldGhpbmcgdXNpbmcgc2VhcmNoIGVuZ2luZSwgeW91IGFyZSBnaXZpbmcgeW91ciBpbmZvcm1hdGlvbiB0byB0aG91c2FuZHMgb2YgM3JkIHBhcnR5IGFkdmVydGlzZXJzPyBWYXN0IGFtb3VudCBvZiB5b3VyIGRhdGEgaGFzIGJlZW4gdGFrZW4gZnJvbSB5b3Ugd2l0aG91dCBhIHNpbmdsZSBjb25zZW50IG9ubHkgdG8gbWFuaXB1bGF0ZSB5b3VyIHB1cmNoYXNlIGhhYml0IGFuZCBsb25nLXRlcm0gYmVoYXZpb3IuIEluIHRoaXMgZXhlcmNpc2UsIHdlIHdpbGwgd2FsayB0aHJvdWdoIHdpdGggeW91IGhvdyB0byBhdm9pZC4uLi4nfVxuXHRcdF1cblx0XHRsZXQgYnJvd3NlckNob2ljZSA9IFtcblx0XHRcdHtuYW1lOiAnR29vZ2xlIENocm9tZScsXG5cdFx0XHR2YWx1ZTogMSxcblx0XHRcdHNhZmV0eTonMzclJyxcblx0XHRcdGJvZHk6J0dvb2dsZSBDaHJvbWUgY29sbGVjdGVzIFggbnVtYmVyIG9mIGluZGl2aWR1YWwgZGF0YSBwZXIgeWVhci4gR29vZ2xlIHByb2JhYmx5IGtub3dzIG1vcmUgYWJvdXQgeW91IHRoYW4gZXZlbiBGYWNlYm9vayBkb2VzLCB0aGFua3MgdG8gdGhlIHRoaW5ncyB5b3UgdGVsbCBpdCB3aGVuIHlvdSB0eXBlIHF1ZXJpZXMgaW50byBpdHMgc2VhcmNoIGVuZ2luZS4gVGhvdWdoIHRoYXTigJlzIGp1c3QgdGhlIHRpcCBvZiBob3cgaXQgdHJhY2tzIHlvdS4gSXQgYWxzbyBoYXMgaXRzIHRyYWNraW5nIGluZnJhc3RydWN0dXJlIGVtYmVkZGVkIG9uIHRocmVlLXF1YXJ0ZXJzIG9mIHRoZSB0b3AgbWlsbGlvbiB3ZWJzaXRlcy4gU28gY2hhbmNlcyBhcmUgaXTigJlzIGZvbGxvd2luZyB3aGF0IHlvdeKAmXJlIGJyb3dzaW5nIG9ubGluZS4nfSxcblx0XHRcdHtuYW1lOiAnRHVja0R1Y2tHbycsXG5cdFx0XHR2YWx1ZTogMixcblx0XHRcdHNhZmV0eTonNzMlJyxcblx0XHRcdGJvZHk6J1NvbWV0aGluZyBzb21ldGhpbmcnfSxcblx0XHRcdHtuYW1lOiAnRHVja0R1Y2tHbycsXG5cdFx0XHR2YWx1ZTogMyxcblx0XHRcdHNhZmV0eToxLFxuXHRcdFx0Ym9keToxLH0sXG5cdFx0XHR7bmFtZTogJ3NvbWV0aGluZzEnLFxuXHRcdFx0dmFsdWU6IDQsXG5cdFx0XHRzYWZldHk6MSxcblx0XHRcdGJvZHk6MSx9LFxuXHRcdFx0e25hbWU6ICdzb21ldGhpbmcyJyxcblx0XHRcdHZhbHVlOiA1LFxuXHRcdFx0c2FmZXR5OjEsXG5cdFx0XHRib2R5OjEsfSxcblx0XHRcdFxuXHRcdF1cblx0XHRcblx0XHQkOiBxID0gMDtcblx0XHRsZXQgaXNBY3RpdmU7XG5cdFx0ZnVuY3Rpb24gc3RlcFVwKCkge1xuXHRcdFx0cSsrO1xuXHRcdFx0cTFTdGVwc1txXS5jbGFzc24gPSAnY29tcGxldGUnO1xuXHRcdFx0aWYgKHEgPT0gMiApe1xuXHRcdFx0XHRpc0FjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocSA+IDIpIHtcblx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdFx0c3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgXHRcdFx0XHRcdHRyYWNrLnN0b3AoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdCQ6IGhlYWRsaW5lID0gcTFTdGVwc1txXS5oMjtcblx0XHQkOiBib2R5ID0gcTFTdGVwc1txXS5jb3B5O1xuXHRcdCQ6IGZyYWN0aW9uID0gcTFTdGVwc1txXS5kO1xuXHRcblx0XHRsZXQgY2hvaWNlID0gWydHb29nbGUgQ2hyb21lJ107XG5cdFx0ZnVuY3Rpb24gc2hvd1Jlc3VsdHMoZXZlbnQpIHtcblx0XHRcdGlzQWN0aXZlID0gdHJ1ZTtcblx0XHR9XG5cdDwvc2NyaXB0PlxuXHQ8c3ZlbHRlOmhlYWQ+XG5cdFx0PHRpdGxlPlNlYXJjaCBFbmdpbmU8L3RpdGxlPlxuXHQ8L3N2ZWx0ZTpoZWFkPlxuXHQ8c2VjdGlvbiBpZD1cInByb2dyZXNzXCI+XG5cdFx0eyNpZiAhaXNBY3RpdmV9XG5cdFx0PGgzPlNlYXJjaCBFbmdpbmUge2ZyYWN0aW9ufTwvaDM+XG5cdFx0PHVsPlxuXHRcdFx0eyNlYWNoIHExU3RlcHMgYXMgc3RlcH1cblx0XHRcdFx0PGxpIGNsYXNzPXtzdGVwLmNsYXNzbn0gPntzdGVwLm5hbWV9PC9saT5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L3VsPlxuXHRcdHs6ZWxzZX1cblx0XHQ8cD5zb21lIHRleHQ8L3A+XG5cdFx0ey9pZn1cblx0PC9zZWN0aW9uPlxuXHQ8ZGl2IGNsYXNzPSdxdWl6LWhvbGRlcic+XG5cdFx0PGgxPntoZWFkbGluZX08L2gxPlxuXHRcdDxwPntib2R5fTwvcD4gXG5cdFx0PGZvcm0+XG5cdFx0XHR7I2VhY2ggYnJvd3NlckNob2ljZSBhcyBicm93c2VycywgaW5kZXh9XG5cdFx0XHRcdDxsYWJlbD5cblx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1yYWRpbyBiaW5kOmdyb3VwPXtjaG9pY2V9IHZhbHVlPXtpbmRleH0+XG5cdFx0XHRcdFx0XHR7YnJvd3NlcnMubmFtZX1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Zvcm0+XG5cdFx0PHNlY3Rpb24gaWQ9J25leHQtc2tpcCc+IFxuXHRcdFx0PGJ1dHRvbiBvbjpjbGljaz17c2hvd1Jlc3VsdHN9IGNsYXNzPSdidG4tZGFyayc+U3VibWl0PC9idXR0b24+XG5cdFx0PC9zZWN0aW9uPlxuXHRcdFxuXHQ8L2Rpdj5cblx0XHRcblx0XHRcblx0PHN0eWxlPlxuXHRcdG1haW57XG5cdFx0XHRmbGV4LWZsb3c6IHJvdyB3cmFwO1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuXHRcdH1cblx0ICAgLnF1aXotaG9sZGVyIHtcblx0XHQgICBkaXNwbGF5OiBibG9jaztcblx0XHQgICB3aWR0aDogNjV2dzsgLyogNzIuNSBvcmlnaW5hbHkgKi9cblx0XHQgICBsZWZ0OiAyMHZ3O1xuXHRcdCAgIGhlaWdodDogMTAwdmg7XG5cdFx0ICAgcGFkZGluZzogMjBweCA1MHB4O1xuXHQgICB9XG5cdCAgIC5zdGVwe1xuXHRcdFx0bWFyZ2luLWJvdHRvbTogNTVweDtcblx0ICAgfVxuXHQgICAjcHJvZ3Jlc3Mge1xuXHRcdCAgIG1hcmdpbi10b3A6IDUwcHg7XG5cdCAgIH1cblx0ICAgdWwge1xuXHRcdCAgIHBhZGRpbmctaW5saW5lLXN0YXJ0OiAxNXB4O1xuXHQgICB9XG5cdCAgIGxpIHtcblx0XHQgICBtYXJnaW46IDMwcHggMHB4O1xuXHQgICB9XG5cdCAgIC5pbmNvbXBsZXRlIHtcblx0XHRcdGNvbG9yOiAjYTBhMGEwO1xuXHRcdFx0bGlzdC1zdHlsZS10eXBlOiBjaXJjbGU7XG5cdFx0fVxuXHRcdC5jb21wbGV0ZSB7XG5cdFx0XHRsaXN0LXN0eWxlLXR5cGU6IGRpc2M7XG5cdFx0fVxuXHRcdC5TaWRlLWhlYWRsaW5lIHtcblx0XHRcdGZvbnQtc2l6ZTogMjRweDtcblx0XHRcdGZvbnQtd2VpZ2h0OiA3MDA7XG5cdFx0fVxuXHRcdC5idG4tZGFyayB7XG5cdFx0XHRjb2xvcjp3aGl0ZTtcblx0XHRcdGJhY2tncm91bmQ6ICMwRjIwMzM7XG5cdFx0XHRib3JkZXItcmFkaXVzOiA2cHg7XG5cdFx0XHR3aWR0aDogMzAlO1xuXHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdFx0cGFkZGluZzogNXB4IDEwcHg7XG5cdFx0fVxuXHRcdGJ1dHRvbiB7XG5cdFx0XHRib3JkZXI6IG5vbmU7XG5cdFx0XHRwYWRkaW5nOiA1cHggMTBweDtcblx0XHR9XG5cdFx0Zm9ybSB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1mbG93OiBjb2x1bW47XG5cdFx0fVxuXHRcdGxhYmVsIHtcblx0XHRcdHBhZGRpbmc6IDEwcHg7XG5cdFx0fVxuXHQ8L3N0eWxlPiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0E0RVUsR0FBTzs7OztrQ0FBWixNQUFJOzs7Ozs7OzswQkFGWSxHQUFROzs7Ozs7Ozs7Ozs7OzswQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OERBQVIsR0FBUTs7OytCQUVuQixHQUFPOzs7O2lDQUFaLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFDcUIsR0FBSSxLQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RUFBeEIsR0FBSSxLQUFDLE1BQU07Ozs7Ozs7O2dFQUFJLEdBQUksS0FBQyxJQUFJOztrR0FBeEIsR0FBSSxLQUFDLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQWNuQixHQUFRLEtBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQUQ4QixHQUFLOzs7Ozs7Ozs7O2dEQUFwQixHQUFNOzs7Ozs7Ozs7Ozs7aURBQU4sR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWpCakMsR0FBUTs7Ozs7O29DQWVOLEdBQWE7Ozs7Z0NBQWxCLE1BQUk7Ozs7Ozs7Ozs7OzswQkFIRixHQUFROzs7c0JBQ1QsR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQURILEdBQVE7Ozs7O3FDQUNULEdBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQVVXLEdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7OzZEQVh6QixHQUFRO3NEQUNULEdBQUk7OzttQ0FFQSxHQUFhOzs7OytCQUFsQixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O29DQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbkZGLFFBQVEsR0FBRyxxQkFBcUI7O1VBRTdCLFFBQVE7RUFDaEIsUUFBUSxDQUFDLFNBQVMsSUFDakIsRUFBRSxFQUFFLE1BQU07OztLQUdQLE9BQU87O0dBQ1QsT0FBTyxFQUFFLEdBQUc7R0FDZCxFQUFFLEVBQUUsZ0NBQWdDO0dBQ3BDLElBQUksRUFBRSxjQUFjO0dBQ3BCLE1BQU0sRUFBRSxVQUFVO0dBQ2xCLENBQUMsRUFBRSxPQUFPO0dBQ1YsUUFBUSxHQUFHLGVBQWUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxXQUFXO0dBQzFFLElBQUksRUFBRSwwVkFBMFY7Ozs7S0FFNVYsYUFBYTs7R0FDZixJQUFJLEVBQUUsZUFBZTtHQUN0QixLQUFLLEVBQUUsQ0FBQztHQUNSLE1BQU0sRUFBQyxLQUFLO0dBQ1osSUFBSSxFQUFDLHdaQUF3Wjs7O0dBQzVaLElBQUksRUFBRSxZQUFZO0dBQ25CLEtBQUssRUFBRSxDQUFDO0dBQ1IsTUFBTSxFQUFDLEtBQUs7R0FDWixJQUFJLEVBQUMscUJBQXFCOzs7R0FDekIsSUFBSSxFQUFFLFlBQVk7R0FDbkIsS0FBSyxFQUFFLENBQUM7R0FDUixNQUFNLEVBQUMsQ0FBQztHQUNSLElBQUksRUFBQyxDQUFDOzs7R0FDTCxJQUFJLEVBQUUsWUFBWTtHQUNuQixLQUFLLEVBQUUsQ0FBQztHQUNSLE1BQU0sRUFBQyxDQUFDO0dBQ1IsSUFBSSxFQUFDLENBQUM7OztHQUNMLElBQUksRUFBRSxZQUFZO0dBQ25CLEtBQUssRUFBRSxDQUFDO0dBQ1IsTUFBTSxFQUFDLENBQUM7R0FDUixJQUFJLEVBQUMsQ0FBQzs7OztLQUtILFFBQVE7O1VBQ0gsTUFBTTttQkFDZCxDQUFDO2tCQUNELE9BQU8sQ0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFHLFVBQVU7O01BQzFCLENBQUMsSUFBSSxDQUFDO21CQUNULFFBQVEsR0FBRyxJQUFJOzs7TUFFWixDQUFDLEdBQUcsQ0FBQztHQUNSLFFBQVE7O0dBQ1IsTUFBTSxDQUFDLFNBQVMsR0FBRyxPQUFPLFdBQVUsS0FBSztJQUN0QyxLQUFLLENBQUMsSUFBSTs7Ozs7S0FRWCxNQUFNLElBQUksZUFBZTs7VUFDcEIsV0FBVyxDQUFDLEtBQUs7a0JBQ3pCLFFBQVEsR0FBRyxJQUFJOzs7Ozs7Ozs7Ozs7OztFQXdCaUIsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTlCcEMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRTs7OztvQkFDeEIsSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsSUFBSTs7OztvQkFDdEIsUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQzs7OzttQkFqQnZCLENBQUMsR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
